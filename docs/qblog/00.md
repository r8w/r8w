---
layout: default
parent: Quote Blog
title: Page 1
nav_order: 1
---

# Page 1

---

## #1

__Source:__ [Object Oriented Programming is Bad](https://www.youtube.com/watch?v=QM1iUe6IofM)

I am a mother one of those old timers - started programming back in 1980. That was with an HP calculator with 15 lines of code and 8 memory registers. There were also the ‚Äòoptical cards‚Äô. You scribble your program onto cards by selecting various numbers, send them off to the mainframe, then a few days later back comes a printout. No keyboards. No monitors, and the printout just as likely to say ‚Äòsyntax error on card 3‚Äô as it is to provide any meaningful result. Imagine, A code, run, test cycle measured in days!

I have been through almost every ‚Äòrevolution‚Äô there has been. Several times. These new fangled technologies come and go out of fashion on roughly a 10 year cycle, just with new TLAs.  I have also been responsible for pushing a fair few of them myself as well as resigning myself to ‚Äòhere we go again‚Äô.

One thing to keep in mind is the Turing Machine. Turing proved that all computers, and all languages, are equivalent. Pretty much, once they can do basic logic, then all languages have equal expressive power. Anything you can do in one, you can do in another. So arguments about procedural vs OO vs Functional are moot. I can write an OO compiler using a procedural language and vice-versa. Not efficient, perhaps, but doable.

So what it comes down to, as mentioned in this video, are the practicalities. In practice, in a real team, with real people with real business problems and challenges. The efficiency of writing and maintaining the code. The efficiency of new hires getting up to speed and the risks of losing people with ‚Äòthe knowledge‚Äô. Building a system that is easy to adapt and extend that Ames the users/customers happy.

This video singles out ‚Äòexcessive OO‚Äô or ‚Äòextreme OO‚Äô as a bad thing - in particular encapsulation. Quell surprise. Excessive anything is a bad thing!

For the comp sci students out there, just remember all these technologies are tools. To be successful in a programming career you will need to master a fair few of them. No real world problem, worth solving, can be done well with a single tool. As a wise boss said to me once, ‚Äòthis is technology. With the right tool it will go 100 times faster‚Äô. This was when I was writing my own ORM layer - not realising there was already a library to do that. Similarly, I once had 85 lines of procedural code replaced with a single line of (damn clever) SQL. Being a programmer is a bit like being a doctor. You can‚Äôt solve every problem with a scalpel. You can‚Äôt solve every problem with antibiotics. Every person is a bit different. You need years of training and a wide variety of diagnostic as well as preventative as well as curative tools, medicines, machines and hands on experience - book learning alone will not cut it.

The main factor for deciding what tools to use is the Problem Domain. One thing I have noticed, time and time again, is that the ‚Äòbest‚Äô computer code accurately reflects the Domain it is working in. I guess it is called DDD these days. From that perspective, and getting back to the video, your encapsulation level should reflect the natural encapsulations of the domain you are working in. Though this is more of a heuristic than an absolute rule.

Let‚Äôs call it ‚ÄòDomain Oriented Heuristic‚Äô programming or DOH programming for short. üëç

---
